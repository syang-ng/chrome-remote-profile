# 开发文档

## daemon.js

守护进程，通过监听开启 `--remote-debugging-port` 的 Chrome 获得当前浏览器的相应数据。

### 运行参数

```shell
-I --ip          Chrome 所对应的相应ip (default: 127.0.0.1)
-P --port        Chrome 所开启的 remote-debugging-port (default: 9222)
-F --forever     是否持续运行 (输入任意参数即可开启持续运行模式)
-A --aliveTime   任何一个 Tab 的最长存在时间 (default: 90s)
-C --checkTime   轮询 Chrome 信息的间隔时间 (default: 30s)
```

### 运行逻辑

#### 初始化

程序通过解析运行时输入的参数来设定程序中的相应变量。这里使用了 nodejs 的 `commander` 模块简化了对参数的处理

如需参考 `commander` 相应文档，可以访问该链接 --->  [Commander.js](https://github.com/tj/commander.js/blob/master/Readme_zh-CN.md)

#### 执行阶段

执行阶段由 `do { ... } while (boolean) ` 的循环组成，通过输入 `forever` 参数可以将循环模式设置为死循环，即时刻运行的服务

在每次执行轮询操作前，程序会先等待相应轮询间隔时间 `checkTime`，避免长轮询带来的性能开销

```javascript
async function main() {
    init();
    do {
        await delay(checkTime);
        try {
            ...
        } catch (err) {
            console.error(err);
        }
    } while (forever);
}
```

#### 轮询操作

在每次轮询中，程序先通过 `chrome-remote-interface` 提供的 `List` 接口，列举出当前浏览器的所有页面

```javascript
const targets = await CDP.List({
    host: config.host,
    port: config.port
});
```

`List` 接口返回的是相应的对象数组，具体格式如下：

```json
[ { description: '',
    devtoolsFrontendUrl: '/devtools/inspector.html?ws=127.0.0.1:9222/devtools/page/(CC3B647FCE8DC944265357A3DDA3775B)',
    faviconUrl: 'https://static.hdslb.com/images/favicon.ico',
    id: '(CC3B647FCE8DC944265357A3DDA3775B)',
    title: '哔哩哔哩 (゜-゜)つロ 干杯~-bilibili',
    type: 'page',
    url: 'https://www.bilibili.com/',
    webSocketDebuggerUrl: 'ws://127.0.0.1:9222/devtools/page/(CC3B647FCE8DC944265357A3DDA3775B)' }]
```

然后程序将遍历该数组并对该数组进行统计，在统计每个页面前，程序会通过一定规则（页面类型判断和白名单策略），过滤掉部分无需判断的页面

```javascript
for(let target of targets) {
    if (target.type !== 'page' || isInWhiteList(target.url)) {
        continue;
    }
}
```

#### 白名单策略

因为 Chrome 浏览器在关闭完所有 Tab 后会主动退出，所以我们应该主动保留某些空白页面，在轮询需要关闭的页面时，主动跳过这些页面

所以程序在每次查询时，会根据相应页面的 url 来判断该页面是否为不需要关闭的页面，如果结果为真则直接跳过当次循环

```javascript
const whiteList = ['chrome://newtab/', 'chrome-extension'];

function isInList(i, array) {
    for(let item of array) {
        if (i.startsWith(item)) {
            return true;
        }
    }
    return false;
}

function isInWhiteList(targetUrl) {
    return isInList(targetUrl, whiteList);
}
```

#### 页面统计

程序通过 `Map` 维持页面对象的 id 属性和其出现次数的键值对，统计页面的出现次数，如果页面存在时间大于其最长存在时间（`count * checkTime >= aliveTime`），则关闭页面（通过 `Close` 接口），反之则修改相应键值对

```javascript
const count = maps.get(target.id) + 1 || 1;
if (count * checkTime >= aliveTime) {
    maps.delete(target.id);
    await CDP.Close({
        host: config.host,
        port: config.port,
        id: target.id
    });
} else {
  maps.set(target.id, count);
}
```

#### 清除失效键值对

这里存在一种情况是，当一个页面正常被关闭前，已经被守护进程所统计，但由于其正常关闭，所以守护进程不会在相应 Map 中删除该页面所对应的键值对，所以这里需要我们在每次清理完异常页面后，对 Map 中的失效数据进行清除

在对每个页面进行判断时，我们需要统计当前存在页面的 id，在上一步操作完成后，我们通过已有的 `ids` 数组，清除失效数据

```javascript
maps.forEach((value, key)=>{
    if (!isInList(key, ids)) {
        maps.delete(key);
    }
});
```

### 补充说明

经过一晚的测试，发现 Chrome 不将崩溃的页面视作当前的有效页面，所以守护进程无法关闭崩溃的页面，不过鉴于相应崩溃对内存占用已经被 Chrome 释放，所以无法关闭崩溃页面的影响较小

## app.js

主程序，自动化 Profiler 核心功能实现

### 运行参数

```shell
-D --dst         输出文件夹 (default: ./profiles)
-I --ip          Chrome 所对应的相应ip (default: 127.0.0.1)
-P --port        Chrome 所开启的 remote-debugging-port (default: 9222)
-T --timeout     分析时间 (default: 12.5 s)
-W --waittime    等待时间 (default: 12.5 s)
-M --max         最大并发标签 (default: 5)
-B --begin       起始 url 对应 id (default: 0)
-E --end         结束 url 对应 id
-C --cover       是否覆盖原数据
-F --forever     是否持续运行
```

### 运行逻辑

#### 初始化

类似 `daemon.js`，`app.js` 初始化主要有四个步骤，为了增加效率，后面三个步骤是并发执行的
1. 通过 `commander` 解析了程序参数
2. 创建数据库线程池的对应实例 `db = new DB();`
3. 检查输出文件夹是否存在
4. 启动 Chrome

#### 轮询操作

程序首先查询最新加入数据库的 url 所对应的 id 是多少，如果大于当前 currentId，那么说明程序有任务待完成，开始对 url 进行分析；反正，则直接进入等待状态，在等待一定时间后，程序开始下一轮轮询

```javascript
do {
    ...
    if (program.end) {
        newId = parseInt(program.end);
        program.end = undefined;
    } else {
        newId = await db.recentId();
    }
    if (newId >= currentId) {
        ...
    } else {
        await delay(60);
    }

} while (forever)
```

#### 任务处理

进程通过 `fetchNewUrls()` 从数据库中取出所有待分析数据开始分析。程序通过 `concurrency: xxx` 控制最大并发数目，并使用 `Promise.race()` 确保资源的释放

```javascript
if (newId >= currentId) {
    /* fecth data */
    const rows = await db.fetchNewUrls(currentId, newId);
    /* run */
    await Promise.map(rows, async (item, index) => {
        if (index < program.max) {
            await delay(program.waittime/program.max*index);
        }
        await Promise.race([
            newTab(item, program.timeout, program.waittime),
            delay(program.waittime*2+program.timeout*5) // 确保资源释放
        ]);
    }, {concurrency: program.max});
    currentId = newId + 1;
}
```

#### 对主线程进行 Profiler

对主线程的 Profiler 过程如下：
1. 首先通过 `enable()` 开启 Profiler
2. 然后通过 `setSamplingInterval()` 设置采样间隔
3. 然后通过 `start()` 启动 Profiler
4. 等待一定时间间隔
5. 通过 `stop()` 结束 Profiler，将获得的数据写入文件

```javascript
try {
    ...
    await Profiler.enable();
    await Profiler.setSamplingInterval({interval: 100});
    await Profiler.start();
    await delay(timeout);
    const {profile} = await Profiler.stop();
    writeJson(id, 0, profile);
    ...
}
```

#### 对其它线程进行 Profiler

与主线程的 Profiler 的过程类似，其它线程的 Profiler 过程仍需要重复上面的几个步骤，只不过由于我们无法直接获得主线程的相应信息，需要更复杂的手段来解决对其它线程的 Profiler 问题

首先需要通过 `Target` 的 `setAutoAttach()` 方法使得程序自动 attach 到其它线程上。然后通过 `attchedToTarget()` 这一监听函数，我们能监听到自动 attach 上线程所对应的 `sessionId`，然后我们需要保存相应的 sessionId

在每次调用 `sendMessageToTarget` 之后，我们都会接收从监听函数 `receivedMessageFromTarget` 处接受来自浏览器的返回数据，从这里我们可以得到对主线程外其它线程的分析结果。当然由于每次调用都会触发该监听函数，所以我们可以通过使用 `Map` 的方式来过滤不需要的数据

```javascript
try {
    ...
    await Target.setAutoAttach({autoAttach: true, waitForDebuggerOnStart: false});
    Target.attachedToTarget(function (obj) {
        if (obj.sessionId !== null) {
            queue.push(obj.sessionId);
        }
    });
    Target.receivedMessageFromTarget(function(obj) {
        const message = JSON.parse(obj.message);
        const number = map.get(message.id);
        if (number !== undefined && message.result.profile !== undefined) {
            writeJson(id, total, message.result.profile);
            total++;
            if (writeTotal !== undefined && total > writeTotal) {
                db.finishProfile(id, total);                        
            }
        }
    });
    ...
    await Promise.map(queue, async function(sessionId) {
        if (sessionId === undefined) {
            return;
        }
        await Target.sendMessageToTarget({
        message: JSON.stringify({id: seq, method:"Profiler.enable"}),
            sessionId: sessionId
        });                  
        seq++;
		await Target.sendMessageToTarget({
            message: JSON.stringify({id: seq, method:"Profiler.setSamplingInterval", params:{interval:100}}),
            sessionId: sessionId
        });           
        seq++;
        await Target.sendMessageToTarget({
            message: JSON.stringify({id: seq, method:"Profiler.start"}),
            sessionId: sessionId
        });
        seq++;
        await delay(timeout);
        await Target.sendMessageToTarget({
            message: JSON.stringify({id: seq, method:"Profiler.stop"}),
            sessionId: sessionId
        });
        map.set(seq, num++);
        seq++;
    }, {concurrency: 1});
}
```